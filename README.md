
# Порівняння Алгоритмів Сортування

## Огляд Алгоритмів

1. **Сортування злиттям**:
   - **Часова складність**: O(n log n) у всіх випадках.
   - **Продуктивність**: 
     - Показує стабільні результати на всіх типах вхідних даних завдяки розподілу та злиттю.
     - Ефективне для великих наборів даних, але не оптимізує майже відсортовані масиви.
   - **Переваги**: Стабільна продуктивність для будь-якого вхідного масиву.
   - **Недоліки**: Потребує додаткової пам'яті для злиття, не має покращень для вже відсортованих даних.

2. **Сортування вставками**:
   - **Часова складність**: O(n²) у найгіршому випадку (масив у зворотному порядку), O(n) у найкращому випадку (вже відсортований масив).
   - **Продуктивність**: 
     - Надзвичайно ефективний для малих і майже відсортованих наборів даних завдяки мінімальним обмінам та порівнянням.
     - Погано працює на великих випадкових або зворотних масивах через квадратичну складність.
   - **Переваги**: Простий і адаптивний для малих або відсортованих вхідних даних.
   - **Недоліки**: Стає повільним зі збільшенням розміру вхідних даних, особливо для невідсортованих масивів.

3. **Timsort** (вбудована функція `sorted` у Python):
   - **Часова складність**: O(n log n) у найгіршому випадку, O(n) для майже відсортованих даних.
   - **Продуктивність**: 
     - Поєднує переваги сортування злиттям та сортування вставками. Автоматично виявляє та оптимізує для вже відсортованих або частково відсортованих сегментів за допомогою сортування вставками.
     - Демонструє майже лінійну продуктивність на відсортованих масивах і підтримує стабільну O(n log n) продуктивність для випадкових і зворотних масивів.
   - **Переваги**: Адаптивний, ефективний та стабільний. Ідеальний для реальних даних, які часто містять відсортовані послідовності.
   - **Недоліки**: Трохи складніший у реалізації через гібридну природу.

## Емпіричні результати
Ми протестували кожен алгоритм на трьох різних типах вхідних даних:
- **Відсортований масив**: вже відсортований список чисел.
- **Масив у зворотному порядку**: список, відсортований за спаданням.
- **Випадковий масив**: список випадкових цілих чисел.

Результати показують:
- **Сортування вставками** працює надзвичайно швидко на відсортованих масивах, перевершуючи сортування злиттям і Timsort у цьому конкретному випадку завдяки лінійній складності.
- **Сортування злиттям** показує стабільні результати на всіх типах вхідних даних, але не оптимізує вже відсортовані масиви, що призводить до довшого часу виконання порівняно з Timsort.
- **Timsort** показує найкращу загальну продуктивність, будучи швидким на випадкових масивах і майже оптимальним на відсортованих даних завдяки своїй гібридній природі.

## Висновки
Можливість Timsort поєднувати сортування злиттям та сортування вставками робить його найефективнішим і найбільш адаптивним алгоритмом для практичного використання. Він оптимізований для реальних даних, саме тому Python використовує його як стандартний алгоритм сортування. Хоча сортування злиттям надійне для стабільної продуктивності, а сортування вставками чудове для малих або відсортованих масивів, Timsort є очевидним лідером з точки зору швидкості та гнучкості.
